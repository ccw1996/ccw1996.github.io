"use strict";(self.webpackChunkblog_sample=self.webpackChunkblog_sample||[]).push([[9917],{1126:(n,t,e)=>{e.r(t),e.d(t,{assets:()=>a,contentTitle:()=>c,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>o});var i=e(5893),p=e(1151);const r={title:"tag_invoke",tags:["work"]},c="\u89e3\u51b3\u65b9\u6cd51",s={id:"cpp/tag_invoke",title:"tag_invoke",description:"http://purecpp.cn/detail?id=2348",source:"@site/docs/cpp/tag_invoke.md",sourceDirName:"cpp",slug:"/cpp/tag_invoke",permalink:"/docs/cpp/tag_invoke",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/edit/main/website/docs/cpp/tag_invoke.md",tags:[{label:"work",permalink:"/docs/tags/work"}],version:"current",lastUpdatedAt:1709135677,formattedLastUpdatedAt:"Feb 28, 2024",frontMatter:{title:"tag_invoke",tags:["work"]},sidebar:"tutorialSidebar",previous:{title:"\u5de6\u503c\u548c\u53f3\u503c",permalink:"/docs/cpp/rvalue"},next:{title:"C++\u6a21\u677f",permalink:"/docs/cpp/template_cpp"}},a={},o=[];function l(n){const t={a:"a",blockquote:"blockquote",code:"code",h1:"h1",p:"p",pre:"pre",...(0,p.a)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"http://purecpp.cn/detail?id=2348",children:"http://purecpp.cn/detail?id=2348"})}),"\n"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:'#include <iostream>\n\nnamespace lib1 {\n\ntemplate <class T>\nvoid print(T const& t) {\n    std::cout << "lib1::print()" << std::endl;  \n}\n\n} // namespace lib1\nnamespace lib2 {\n\nstruct w {\n    int x_;\n};\n\nvoid print(w const&) {\n    std::cout << "lib2::print()" << std::endl;\n}\n\n} // namespace lib2\n\nlib2::w x;\nlib1::print(x); // #1 lib1::print -- NOT EXPECTED\nlib2::print(x); // #2 lib2::print\n\nusing namespace lib1;\nprint(x);       // #3 lib2::print -- ADL\n'})}),"\n",(0,i.jsx)(t.p,{children:"\u5f53\u6211\u4eec\u5728\u57fa\u7840\u5e93 lib1 \u4e2d\u5b9a\u4e49 print \u65b9\u6cd5\u540e\uff0c\u5e0c\u671b\u7528\u6237\u53ef\u4ee5\u6839\u636e\u81ea\u5df1\u7684\u9700\u8981\u81ea\u5b9a\u4e49 print \u7684\u884c\u4e3a\u3002\u5982\u4e0a\u8ff0\u4ee3\u7801\uff0c\u671f\u671b\u4ee5\u9650\u5b9a\u540d lib1::print(x) \u8c03\u7528\u65f6\u53ef\u4ee5\u8c03\u7528\u7528\u6237\u81ea\u5b9a\u4e49\u7684\u4ee3\u7801\uff0c\u7136\u800c\u5e76\u6ca1\u6709\u8fbe\u5230\u671f\u671b\u3002"}),"\n",(0,i.jsx)(t.h1,{id:"\u89e3\u51b3\u65b9\u6cd51",children:"\u89e3\u51b3\u65b9\u6cd51"}),"\n",(0,i.jsx)(t.p,{children:"\u5f53\u628a\u51fd\u6570\u63d0\u5347\u4e3a\u5bf9\u8c61\u540e\u53ef\u4ee5\u907f\u514d\u53c2\u6570\u4f9d\u8d56\u67e5\u627e\uff0c\u7136\u540e\u5728\u5bf9\u8c61\u5185\u6b63\u786e\u5904\u7406\u9700\u8981\u8c03\u7528\u7684\u51fd\u6570\uff0c\u5982\u4e0a\u8ff0\u4ee3\u7801\u3002"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:'#include <iostream>\n\nnamespace lib1 {\nnamespace cpo {\n\nstruct print_t {\n    template <class T>\n    friend void print(T const& t) {\n        std::cout << "lib1::print()" << std::endl;  \n    }\n\n    template <class T>\n    constexpr void operator()(T&& t) const {\n        return print(t);\n    }\n};\n\n} // namespace cpo\n\nconstexpr cpo::print_t print;\n\n} // namespace lib1\n\n// ... lib2 code ...\n\nlib2::w x;\nlib1::print(x); // #1 lib2::print -- EXPECTED\nlib2::print(x); // #2 lib2::print\n\nusing namespace lib1;\nprint(x);       // #3 lib2::print -- EXPECTED\n'})}),"\n",(0,i.jsx)(t.h1,{id:"\u89e3\u6cd5\u65b9\u6cd52",children:"\u89e3\u6cd5\u65b9\u6cd52"}),"\n",(0,i.jsx)(t.p,{children:"tag_invoke"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:'#include <iostream>\n#include <type_traits>\n\nnamespace lib1 {\n\nconstexpr struct tag_invoke_t {\n    template <class CPO, class T>\n    constexpr void operator()(CPO&& cpo, T&& t) const {\n        return tag_invoke(std::forward<CPO>(cpo), std::forward<T>(t));\n    }\n} tag_invoke;\n\nnamespace cpo {\n\nstruct print_t {\n    template <class T>\n    friend void tag_invoke(print_t, T const& t) {\n        std::cout << "lib1::print()" << std::endl;  \n    }\n\n    template <class T>\n    constexpr void operator()(T&& t) const {\n        return lib1::tag_invoke(print_t{}, std::forward<T>(t));\n    }\n};\n\n} // namespace cpo\n\nconstexpr cpo::print_t print;\n\n} // namespace lib1\nnamespace lib2 {\n\n// ... struct w ...\n\nvoid tag_invoke(std::remove_cvref_t<decltype(lib1::print)>, w const&) {\n    std::cout << "lib2::print()" << std::endl;\n}\n\n} // namespace lib2\n\nlib2::w x;\nlib1::print(x); // #1 lib2::print -- EXPECTED\n\nusing namespace lib1;\nprint(x);       // #2 lib2::print -- EXPECTED\n'})})]})}function d(n={}){const{wrapper:t}={...(0,p.a)(),...n.components};return t?(0,i.jsx)(t,{...n,children:(0,i.jsx)(l,{...n})}):l(n)}},1151:(n,t,e)=>{e.d(t,{Z:()=>s,a:()=>c});var i=e(7294);const p={},r=i.createContext(p);function c(n){const t=i.useContext(r);return i.useMemo((function(){return"function"==typeof n?n(t):{...t,...n}}),[t,n])}function s(n){let t;return t=n.disableParentContext?"function"==typeof n.components?n.components(p):n.components||p:c(n.components),i.createElement(r.Provider,{value:t},n.children)}}}]);