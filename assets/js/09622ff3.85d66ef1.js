"use strict";(self.webpackChunkblog_sample=self.webpackChunkblog_sample||[]).push([[1199],{3272:(n,t,e)=>{e.r(t),e.d(t,{assets:()=>a,contentTitle:()=>s,default:()=>d,frontMatter:()=>c,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"cpp/tag_invoke","title":"tag_invoke","description":"http://purecpp.cn/detail?id=2348","source":"@site/docs/cpp/tag_invoke.md","sourceDirName":"cpp","slug":"/cpp/tag_invoke","permalink":"/docs/cpp/tag_invoke","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/edit/main/website/docs/cpp/tag_invoke.md","tags":[{"inline":true,"label":"work","permalink":"/docs/tags/work"}],"version":"current","lastUpdatedAt":1740785860000,"frontMatter":{"title":"tag_invoke","tags":["work"]},"sidebar":"tutorialSidebar","previous":{"title":"\u5de6\u503c\u548c\u53f3\u503c","permalink":"/docs/cpp/rvalue"},"next":{"title":"C++\u6a21\u677f","permalink":"/docs/cpp/template_cpp"}}');var r=e(4848),p=e(8453);const c={title:"tag_invoke",tags:["work"]},s="\u89e3\u51b3\u65b9\u6cd51",a={},o=[];function l(n){const t={a:"a",blockquote:"blockquote",code:"code",h1:"h1",header:"header",p:"p",pre:"pre",...(0,p.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(t.blockquote,{children:["\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.a,{href:"http://purecpp.cn/detail?id=2348",children:"http://purecpp.cn/detail?id=2348"})}),"\n"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cpp",children:'#include <iostream>\n\nnamespace lib1 {\n\ntemplate <class T>\nvoid print(T const& t) {\n    std::cout << "lib1::print()" << std::endl;  \n}\n\n} // namespace lib1\nnamespace lib2 {\n\nstruct w {\n    int x_;\n};\n\nvoid print(w const&) {\n    std::cout << "lib2::print()" << std::endl;\n}\n\n} // namespace lib2\n\nlib2::w x;\nlib1::print(x); // #1 lib1::print -- NOT EXPECTED\nlib2::print(x); // #2 lib2::print\n\nusing namespace lib1;\nprint(x);       // #3 lib2::print -- ADL\n'})}),"\n",(0,r.jsx)(t.p,{children:"\u5f53\u6211\u4eec\u5728\u57fa\u7840\u5e93 lib1 \u4e2d\u5b9a\u4e49 print \u65b9\u6cd5\u540e\uff0c\u5e0c\u671b\u7528\u6237\u53ef\u4ee5\u6839\u636e\u81ea\u5df1\u7684\u9700\u8981\u81ea\u5b9a\u4e49 print \u7684\u884c\u4e3a\u3002\u5982\u4e0a\u8ff0\u4ee3\u7801\uff0c\u671f\u671b\u4ee5\u9650\u5b9a\u540d lib1::print(x) \u8c03\u7528\u65f6\u53ef\u4ee5\u8c03\u7528\u7528\u6237\u81ea\u5b9a\u4e49\u7684\u4ee3\u7801\uff0c\u7136\u800c\u5e76\u6ca1\u6709\u8fbe\u5230\u671f\u671b\u3002"}),"\n",(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"\u89e3\u51b3\u65b9\u6cd51",children:"\u89e3\u51b3\u65b9\u6cd51"})}),"\n",(0,r.jsx)(t.p,{children:"\u5f53\u628a\u51fd\u6570\u63d0\u5347\u4e3a\u5bf9\u8c61\u540e\u53ef\u4ee5\u907f\u514d\u53c2\u6570\u4f9d\u8d56\u67e5\u627e\uff0c\u7136\u540e\u5728\u5bf9\u8c61\u5185\u6b63\u786e\u5904\u7406\u9700\u8981\u8c03\u7528\u7684\u51fd\u6570\uff0c\u5982\u4e0a\u8ff0\u4ee3\u7801\u3002"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cpp",children:'#include <iostream>\n\nnamespace lib1 {\nnamespace cpo {\n\nstruct print_t {\n    template <class T>\n    friend void print(T const& t) {\n        std::cout << "lib1::print()" << std::endl;  \n    }\n\n    template <class T>\n    constexpr void operator()(T&& t) const {\n        return print(t);\n    }\n};\n\n} // namespace cpo\n\nconstexpr cpo::print_t print;\n\n} // namespace lib1\n\n// ... lib2 code ...\n\nlib2::w x;\nlib1::print(x); // #1 lib2::print -- EXPECTED\nlib2::print(x); // #2 lib2::print\n\nusing namespace lib1;\nprint(x);       // #3 lib2::print -- EXPECTED\n'})}),"\n",(0,r.jsx)(t.h1,{id:"\u89e3\u6cd5\u65b9\u6cd52",children:"\u89e3\u6cd5\u65b9\u6cd52"}),"\n",(0,r.jsx)(t.p,{children:"tag_invoke"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cpp",children:'#include <iostream>\n#include <type_traits>\n\nnamespace lib1 {\n\nconstexpr struct tag_invoke_t {\n    template <class CPO, class T>\n    constexpr void operator()(CPO&& cpo, T&& t) const {\n        return tag_invoke(std::forward<CPO>(cpo), std::forward<T>(t));\n    }\n} tag_invoke;\n\nnamespace cpo {\n\nstruct print_t {\n    template <class T>\n    friend void tag_invoke(print_t, T const& t) {\n        std::cout << "lib1::print()" << std::endl;  \n    }\n\n    template <class T>\n    constexpr void operator()(T&& t) const {\n        return lib1::tag_invoke(print_t{}, std::forward<T>(t));\n    }\n};\n\n} // namespace cpo\n\nconstexpr cpo::print_t print;\n\n} // namespace lib1\nnamespace lib2 {\n\n// ... struct w ...\n\nvoid tag_invoke(std::remove_cvref_t<decltype(lib1::print)>, w const&) {\n    std::cout << "lib2::print()" << std::endl;\n}\n\n} // namespace lib2\n\nlib2::w x;\nlib1::print(x); // #1 lib2::print -- EXPECTED\n\nusing namespace lib1;\nprint(x);       // #2 lib2::print -- EXPECTED\n'})})]})}function d(n={}){const{wrapper:t}={...(0,p.R)(),...n.components};return t?(0,r.jsx)(t,{...n,children:(0,r.jsx)(l,{...n})}):l(n)}},8453:(n,t,e)=>{e.d(t,{R:()=>c,x:()=>s});var i=e(6540);const r={},p=i.createContext(r);function c(n){const t=i.useContext(p);return i.useMemo((function(){return"function"==typeof n?n(t):{...t,...n}}),[t,n])}function s(n){let t;return t=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:c(n.components),i.createElement(p.Provider,{value:t},n.children)}}}]);