<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-cpp/interview" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.7.0">
<title data-rh="true">C++面试考点 | 萝卜菜在种树</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://ccw1996.github.io/docs/cpp/interview"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="C++面试考点 | 萝卜菜在种树"><meta data-rh="true" name="description" content="引用和指针的区别"><meta data-rh="true" property="og:description" content="引用和指针的区别"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://ccw1996.github.io/docs/cpp/interview"><link data-rh="true" rel="alternate" href="https://ccw1996.github.io/docs/cpp/interview" hreflang="en"><link data-rh="true" rel="alternate" href="https://ccw1996.github.io/docs/cpp/interview" hreflang="x-default"><link data-rh="true" rel="preconnect" href="https://FUU659621Z-dsn.algolia.net" crossorigin="anonymous"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="萝卜菜在种树 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="萝卜菜在种树 Atom Feed">




<link rel="search" type="application/opensearchdescription+xml" title="萝卜菜在种树" href="/opensearch.xml"><link rel="stylesheet" href="/assets/css/styles.4c7c384b.css">
<script src="/assets/js/runtime~main.ce01a94a.js" defer="defer"></script>
<script src="/assets/js/main.2f500d7f.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const n=new URLSearchParams(window.location.search).entries();for(var[t,e]of n)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">My Site</b></a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite" aria-pressed="false"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search (Command+K)"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20" aria-hidden="true"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/24-08">24-08</a><button aria-label="Expand sidebar category &#x27;24-08&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/24-11">24-11</a><button aria-label="Expand sidebar category &#x27;24-11&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/25-02">25-02</a><button aria-label="Expand sidebar category &#x27;25-02&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/LLM">LLM</a><button aria-label="Expand sidebar category &#x27;LLM&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" href="/docs/cpp">cpp</a><button aria-label="Collapse sidebar category &#x27;cpp&#x27;" aria-expanded="true" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/cpp/summarycpp">总结 C/C++ 知识</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/cpp/CRTP">CRTP</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" tabindex="0" href="/docs/cpp/STL">STL</a><button aria-label="Expand sidebar category &#x27;STL&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/cpp/Singleton">C++ 单例</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/cpp/constexpr">c++之constexpr</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/cpp/construct_function">C++之构造函数</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/cpp/coroutines">c++20 协程</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/cpp/cpp14">C++14 新特性</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/cpp/cpp17">C++17常用新特性</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/cpp/inline">inline 总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/cpp/interview">C++面试考点</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/cpp/lambda">C++   的 lambda 表达式</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/cpp/map">如何修改map容器</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/cpp/multi_thread">多线程总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/cpp/noexcept">noexcept</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/cpp/perfect_forwarding">C++11完美转发及实现方法详解</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/cpp/rvalue">左值和右值</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/cpp/tag_invoke">tag_invoke</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/cpp/template_cpp">C++模板</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/cpp/union">union共用体</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/cpp/volatile">volatile 解剖</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" tabindex="0" href="/docs/cpp/work">work</a><button aria-label="Expand sidebar category &#x27;work&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/cpp/泛型函数">泛型分割函数</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/cuda">cuda</a><button aria-label="Expand sidebar category &#x27;cuda&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/design_model">design_model</a><button aria-label="Expand sidebar category &#x27;design_model&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/ml">ml</a><button aria-label="Expand sidebar category &#x27;ml&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/other">other</a><button aria-label="Expand sidebar category &#x27;other&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/python">python</a><button aria-label="Expand sidebar category &#x27;python&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/stable_diffusion">stable_diffusion</a><button aria-label="Expand sidebar category &#x27;stable_diffusion&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/time">time</a><button aria-label="Expand sidebar category &#x27;time&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/triton">triton</a><button aria-label="Expand sidebar category &#x27;triton&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/docs/cpp"><span itemprop="name">cpp</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">C++面试考点</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>C++面试考点</h1></header><h2 class="anchor anchorWithStickyNavbar_LWe7" id="引用和指针的区别">引用和指针的区别<a href="#引用和指针的区别" class="hash-link" aria-label="Direct link to 引用和指针的区别" title="Direct link to 引用和指针的区别">​</a></h2>
<p>初始化:
<strong>引用在定义的时候必须进行初始化</strong>，并且不能够改变
指针在定义的时候不一定要初始化，并且指向的空间可变
访问逻辑不同:
通过指针访问对象, 用户需要使用间接访问
通过引用访问对象, 用户只需使用直接访问, 编译器负责将其处理为间接访问
运算结果不同:
<strong>传指针的实质是传值，传递的值是指针内储存的变量地址</strong>；
传引用的实质是传地址，传递的是变量的地址。
指针通过下标运算结果是指针所指值为基地址加上偏移, 且基地址可变.
引用通过下标运算结果是引用的是数组才能有这个操作.
自增运算结果不同
<code>sizeof</code>运算的结果不同
下标运算:
函数参数:
多级: 有多级指针，但是没有多级引用，只能有一级引用。
<a href="https://blog.csdn.net/toyijiu/article/details/99729949" target="_blank" rel="noopener noreferrer">C++ 引用占用内存</a>
引用实际是 通过指针实现的。
引用是一个常量指针
引用在内存中占4个字节。
在对引用定义时，需要对这个常量指针初始化。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="c中的指针参数传递和引用参数传递">C++中的指针参数传递和引用参数传递<a href="#c中的指针参数传递和引用参数传递" class="hash-link" aria-label="Direct link to C++中的指针参数传递和引用参数传递" title="Direct link to C++中的指针参数传递和引用参数传递">​</a></h2>
<p><strong>指针参数传递的本质是值传递, 传递的值是对象的地址</strong>
<strong>引用参数传递的本质是传地址, 传递的是实参变量的地址</strong>
从逻辑上引用相当于对变量起了一个别名, 通过该别名可以对变量进行直接访问, 由编译器负责将直接访问转换为间接访问; 而指针访问变量都是间接访问.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="形参与实参的区别">形参与实参的区别<a href="#形参与实参的区别" class="hash-link" aria-label="Direct link to 形参与实参的区别" title="Direct link to 形参与实参的区别">​</a></h2>
<p>形参属于函数内部的局部变量, 在调用函数时才会分配内存, 在函数调用之后会被释放掉, 因此在函数内部才有效
实参可以使常量, 表达式, 函数等, 无论是何种类型,在函数调用时都必须有一个确定的值,以便把函数的值传递给形参
实参和形参的个数一定要严格匹配(当然可以忽略有默认值形参), 通常情况下函数类型也是应该严格匹配的, 但是允许隐式类型变换,如果类中定义了零参数构造函数,甚至可以使用空初始化列表 <code>{}</code> 的方式调用零参数构造函数
实参到形参的传递是单向的
形参类型为非指针非引用, 则传递方式为值传递则, 形参为实参的副本, 对形参的任何修改都不会反应在主调函数中</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="static的用法"><code>static</code>的用法<a href="#static的用法" class="hash-link" aria-label="Direct link to static的用法" title="Direct link to static的用法">​</a></h2>
<p>主要可以分为五个类型: 全局静态变量, 局部静态变量, 静态函数, 静态成员变量, 静态成员函数</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="静态函数">静态函数<a href="#静态函数" class="hash-link" aria-label="Direct link to 静态函数" title="Direct link to 静态函数">​</a></h3>
<p>在函数返回类型前加<code>static</code>，函数就定义为静态函数。<strong>函数的定义和声明在默认情况下都是<code>extern</code>的</strong>，但<strong>静态函数只是在声明他的文件当中可见，不能被其他文件所用</strong>。
函数的实现使用<code>static</code>修饰，<strong>那么这个函数只可在本<code>cpp</code>内使用，不会同其他<code>cpp</code>中的同名函数引起冲突；</strong>
<code>warning</code>：不要再头文件中声明<code>static</code>的全局函数，不要在<code>cpp</code>内声明非<code>static</code>的全局函数，如果你要在多个<code>cpp</code>中复用该函数，就把它的声明提到头文件里去，否则<code>cpp</code>内部声明需加上<code>static</code>修饰；</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="类的静态成员">类的静态成员<a href="#类的静态成员" class="hash-link" aria-label="Direct link to 类的静态成员" title="Direct link to 类的静态成员">​</a></h3>
<p>在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。
因此，<strong>静态成员是类的所有对象中共享的成员，而不是某个对象的成员</strong>。对多个对象来说，静态数据成员只存储一处，供所有对象共用</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="类的静态函数">类的静态函数<a href="#类的静 态函数" class="hash-link" aria-label="Direct link to 类的静态函数" title="Direct link to 类的静态函数">​</a></h3>
<p><strong>静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员</strong>。因此，对静态成员的引用不需要用对象名。
<strong>在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员(这点非常重要)</strong>。*如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：::();*参数表&gt;静态成员函数名&gt;类名&gt;
不能被<code>virtual</code>修饰,静态成员函数没有<code>this</code> 指针，虚函数的实现是为每一个对象分配一个<code>vptr</code> 指针，而<code>vptr</code> 是通过<code>this</code> 指针调用的，所以不能为<code>virtual</code>；虚函数的调用关系，<code>this</code>-&gt;<code>vptr</code>-&gt;<code>ctable</code>-&gt;<code>virtual function</code></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="静态变量什么时候初始化">静态变量什么时候初始化<a href="#静态变量什么时候初始化" class="hash-link" aria-label="Direct link to 静态变量什么时候初始化" title="Direct link to 静态变量什么时候初始化">​</a></h2>
<p>但在 <code>C</code>  和 <code>C++</code> 中静态局部变量的初始化节点又有点不太一样。
在<code>C</code>中，<strong>初始化发生在代码执行之前，编译阶段分配好内存之后，就会进行初始化</strong>，所以我们看到^^在<code>C</code> 语言中无法使用变量对静态局部变量进行初始化^^，在程序运行结束，变量所处的全局内存会被全部回收。
而在<code>C++</code>中，<strong>初始化时在执行相关代码时才会进行初始化</strong>，主要是由于<code>C++</code>引入对象后，要进行初始化必须执行相应构造函数和析构函数，在构造函数或析构函数中经常会需要进行某些程序中需要进行的特定操作，并非简单地分配内存。所以 <strong><code>C++</code>标准规定为全局或静态对象是有首次用到时才会进行构造</strong> ，并通过<code>atexit()</code>来管理。在程序结束，按照构造顺序反方向进行逐个析构。所以在 <strong><code>C++</code>中是可以使用变量对静态局部变量进行初始化的。</strong></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="mutable"><code>mutable</code><a href="#mutable" class="hash-link" aria-label="Direct link to mutable" title="Direct link to mutable">​</a></h2>
<p>如果需要在 <code>const</code>  成员方法中修改一个成员变量的值，那么需要将这个成员变量修饰为 <code>mutable</code> 。<strong>即用<code>mutable</code> 修饰的成员变量不受<code>const</code> 成员方法的限制;</strong>
可以认为 <code>mutable</code>  的变量是类的辅助状态，但是只是起到类的一些方面表述的功能，修改他的内容我们可以认为对象的状态本身并没有改变的。实际上由于 <code>const_cast</code> 的存在，这个概念很多时候用处不是很到了。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="extern-用法"><code>extern</code> 用法？<a href="#extern-用法" class="hash-link" aria-label="Direct link to extern-用法" title="Direct link to extern-用法">​</a></h2>
<p><code>extern</code>  修饰变量的声明
如果文件<code>a.c</code> 需要引用<code>b.c</code> 中变量<code>int v</code>，就可以在<code>a.c</code> 中声明<code>extern int v</code>，然后就可以引用变量<code>v</code>。
<code>extern</code>  修饰函数的声明
如果文件<code>a.c</code> 需要引用<code>b.c</code> 中的函数，比如在<code>b.c</code> 中原型是<code>int fun(int mu)</code>，那么就可以在<code>a.c</code> 中声明<code>extern int fun(int mu)</code>，然后就能使用<code>fun</code> 来做任何事情。
就像变量的声明一样，<code>extern int fun(int mu)</code>可以放在<code>a.c</code> 中任何地方，而不一定非要放在<code>a.c</code> 的文件作用域的范围中。
默认情况情况下函数都是<code>extern</code>的, 除非使用<code>static</code>对函数进行了隐匿
<code>extern</code>  修饰符可用于指示 <code>C</code>  或者 <code>C++</code> 函数的调用规范。
比如在<code>C++</code>中调用<code>C</code> 库函数，就需要在<code>C++</code>程序中用<code>extern “C”</code>声明要引用的函数。这是给链接器用的，告诉链接器在链接的时候用<code>C</code> 函数规范来链接。主要原因是<code>C++</code>和<code>C</code> 程序编译完成后在目标代码中命名规则不同。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="虚函数可以声明为inline吗">虚函数可以声明为<code>inline</code>吗?<a href="#虚函数可以声明为inline吗" class="hash-link" aria-label="Direct link to 虚函数可以声明为inline吗" title="Direct link to 虚函数可以声明为inline吗">​</a></h2>
<p><strong>虚函数要求在运行时进行类型确定，而内敛函数要求在编译期完成相关的函数替换, 所以不能</strong>
虚函数用于实现运行时的多态，或者称为晚绑定或动态绑定。
内联函数用于提高效率, 对于程序中需要频繁使用和调用的小函数非常有用。它是在<strong>编译期间</strong>，对调用内联函数的地方的代码<strong>替换</strong>成函数代码。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="类成员初始化方式构造函数的执行顺序为什么用成员初始化列表会快一些">类成员初始化方式？构造函数的执行顺序？为什么用成员初始化列表会快一些？<a href="#类成员初始化方式构造函数的执行顺序为什么用成员初始化列表会快一些" class="hash-link" aria-label="Direct link to 类成员初始化方式？构造函数的执行顺序？为什么用成员  初始化列表会快一些？" title="Direct link to 类成员初始化方式？构造函数的执行顺序？为什么用成员初始化列表会快一些？">​</a></h2>
<p>概念
赋值初始化，通过在函数体内进行赋值初始化；
列表初始化，在冒号后使用初始化列表进行初始化。
这两种方式的主要区别在于：
对于在<strong>函数体中初始化</strong>,是在所有的成员函数分配空间后才进行的。<strong>对于类对象类型成员变量, 则是先调用零参数构造函数, 如果零参数构造函数不存在编译器将会报错.</strong>
列表初始化是给数据成员分配内存空间时就进行初始化,就是说分配一个数据成员只要冒号后有此数据成员的赋值表达式(此表达式必须是括号赋值表达式)。
快的原因: 所以对于列表初始化: 只进行了一次初始化操作, 而赋值初始化则先进性了一次初始化,然后调用了一次复制构造函数.
一个派生类构造函数的执行顺序如下：
<strong>虚基类</strong>的构造函数(多个虚拟基类则按照继承的顺序执行构造函数)。
<strong>基类</strong>的构造函数(多个普通基类也按照继承的顺序执行构造函数)。
<strong>类类型的成员对象</strong>的构造函数(按照初始化顺序)
派生类<strong>自己的构造函数</strong>。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="构造函数为什么不能为虚函数析构函数为什么要虚函数">构造函数为什么不能为虚函数？析构函数为什么要虚函数？<a href="#构造函数为什么不能为虚函数析构函数为什么要虚函数" class="hash-link" aria-label="Direct link to 构造函数为什么不能为虚函数？析构函数为什么要虚函数？" title="Direct link to 构造函数为什么不能为虚函数？析构函数为什么要虚函数？">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="构造函数为什么不能为虚函数">构造函数为什么不能为虚函数?<a href="#构造函数为什么不能为虚函数" class="hash-link" aria-label="Direct link to 构造函数为什么不能为虚函数?" title="Direct link to 构造函数为什么不能为虚函数?">​</a></h3>
<p>首先是没必要使用虚函数:
由于使用间接调用(通过引用或则指针)导致类<strong>类型不可信</strong>, 而使用虚函数机制完成正确的函数调用.
但是构造函数本身是为了初始化对象实例, 创建对象必须制定它的类型, 其类类型是明确的, 因此在编译期间即可确定调用函数入口地址
因而没必要使用虚函数, 其调用在编译时由编译器已经确定.
其次不能使用虚函数:
虚函数的调用依赖于虚函数表, 虚函数表储存于静态储存区, 在存在虚函数的对象中都将插入一个指向虚函数表的指针,
在对象中插入一个指向虚函数表的指针是由构造函数完成的, 也就是说在调用构造函数时并没有指向虚函数表的指针, 也就不能完成虚函数的调用.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="析构函数为什么要虚函数">析构函数为什么要虚函数？<a href="#析构函数为什么要虚函数" class="hash-link" aria-label="Direct link to 析构函数为什么要虚函数？" title="Direct link to 析构函数为什么要虚函数？">​</a></h3>
<p><code>C++</code> 中基类采用 <code>virtual</code>  虚析构函数是为了防止内存泄漏。
如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。
假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数。那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。
所以，为了防止这种情况的发生，<code>C++</code>中基类的析构函数应采用<code>virtual</code> 虚析构函数。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="析构函数的作用如何起作用">析构函数的作用，如何起作用？<a href="#析构函数的作用如何起作用" class="hash-link" aria-label="Direct link to 析构函数的作用，如何起作用？" title="Direct link to 析构函数的作用，如何起作用？">​</a></h2>
<p>析构函数名与类名相同,只是在函数名前增加了取反符号 <code>~</code> 以区别于构造函数,其不带任何参数, 也<strong>没有返回值</strong>. 也<strong>不允许重载</strong>.
析构函数与构造函数的作用相反, 当对象生命周期结束的时候,如对象所在函数被调用完毕时,析构函数负责结束对象的生命周期. <strong>注意如果类对象中分配了堆内存一定要在析构函数中进行释放.</strong>
和拷贝构造函数类似,如果用户未定义析构函数, 编译器<strong>并不是一定</strong>会自动合成析构函数, 只有在<strong>成员变量或则基类</strong>拥有析构函数的情况下它才会自动合成析构函数.
如果<strong>成员变量或则基类</strong>拥有析构函数, 则编译器一定会合成析构函数, 负责调用成员变量或则基类的析构函数, 此时如果用户提供了析构函数,则编译器会在用户析构函数之后添加上述代码.
类析构的顺序为: 派生类析构函数, 对象成员析构函数, 基类析构函数.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="构造函数和析构函数可以调用虚函数吗">构造函数和析构函数可以调用虚函数吗<a href="#构造函数和析构函数可以调用虚函数吗" class="hash-link" aria-label="Direct link to 构造函数和析构函数可以调用虚函数吗" title="Direct link to 构造函数和析构函数可以调用虚函数吗">​</a></h2>
<p>在C++中，提倡不在构造函数和析构函数中调用虚函数；
在构造函数和析构函数调用的所有函数(包括虚函数)都是编译时确定的, 虚函数将运行该类中的版本.
因为<strong>父类对象会在子  类之前进行构造</strong>，此时子类部分的数据成员还未初始化，因此调用子类的虚函数时不安全的，故而C++不会进行动态联编；
析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数。所以在调用基类的析构函数时，派生类对象的数据成员已经销毁，这个时候再调用子类的虚函数没有任何意义。
构造顺序
基类构造函数、对象成员构造函数、派生类本身的构造函数
特例
局部对象，在退出程序块时析构
静态对象，在定义所在文件结束时析构
全局对象，在程序结束时析构
继承对象，先析构派生类，再析构父类
对象成员，先析构类对象，再析构对象成员</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="虚析构函数的作用父类的析构函数是否要设置为虚函数">虚析构函数的作用，父类的析构函数是否要设置为虚函数？<a href="#虚析构函数的作用父类的析构函数是否要设置为虚函数" class="hash-link" aria-label="Direct link to 虚析构函数的作用，父类的析构函数是否要设置为虚函数？" title="Direct link to 虚析构函数的作用，父类的析构函数是否要设置为虚函数？">​</a></h2>
<p><code>C++</code> 中基类采用 <code>virtual</code> 虚析构函数是为了防止内存泄漏。
如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。
假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数。那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。
所以，为了防止这种情况的发生， <code>C++</code> 中基类的析构函数应采用 <code>virtual</code> 虚析构函数。
<strong>纯虚析构函数一定得有定义</strong>，因为每一个派生类析构函数会被编译器加以扩张，以静态调用的方式调用其每一个虚基类以及上一层基类的析构函数。<strong>因此缺乏任何一个基类析构函数的定义，就会导致链接失败。</strong>^^因此，最好不要把虚析构函数定义为纯虚析构函数。^^</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="构造函数---析构函数--可以调用虚函数吗"><code>构造函数</code>   <code>析构函数</code>  可以调用虚函数吗？<a href="#构造函数---析构函数--可以调用虚函数吗" class="hash-link" aria-label="Direct link to 构造函数---析构函数--可以调用虚函数吗" title="Direct link to 构造函数---析构函数--可以调用虚函数吗">​</a></h2>
<p>在 <code>构造函数</code> 和 <code>析构函数</code> 中最好不要调用虚函数；
在 <code>构造函数</code> 和 <code>析构函数</code> 中调用的成员函数都是属于<strong>编译时确定</strong>的,并<strong>不具有虚函数的动态绑定特性</strong>, 有如下原因:
<strong>在构造时, 父类对象总是先于子类对象构造</strong>的, 如果父类的析构函数使用虚函数机制调用子类的函数, 结果将是不可预料的
<strong>在析构时, 子类的析构函数总是先于父类</strong>执行, 如果父类的析构函数使用虚函数机制调用子类的函数, 结果将是不可预料的</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="构造函数-----析构函数--可否抛出异常"><code>构造函数</code>  ,    <code>析构函数</code>  可否抛出异常<a href="#构造函数-----析构函数--可否抛出异常" class="hash-link" aria-label="Direct link to 构造函数-----析构函数--可否抛出异常" title="Direct link to 构造函数-----析构函数--可否抛出异常">​</a></h2>
<p>构造函数异常
后果:
<strong>(原因):</strong> <code>C++</code> 拒绝为<strong>没有完成构造函数的对象</strong>调用<strong>析构函数</strong>，原因是避免  开销
构造函数中发生异常，控制权转出构造函数。如果构造函数中申请了堆内存, 则堆内存将无法释放, 从而造成内存泄漏
例如: 在对象 <code>b</code> 的构造函数中发生异常，对象 <code>b</code> 的析构函数不会被调用。<strong>因此会造成内存泄漏</strong>。
解决方案:
使用<strong>智慧指针</strong>来管理堆内存. 其不需要在析构函数中手动释放资源. 在发生异常时, 智慧指针会自动释放资源从而避免了内存泄漏.
<strong>一般建议不要在构造函数里做过多的资源分配。</strong>
析构函数异常
后果:
在异常传递的<strong>堆栈辗转开解</strong>的过程中, 如果发生析构异常,  <code>C++</code> 会调用 <code>terminate</code> 终止程序
如果析构函数发生发生异常，则异常后面的代码将不执行，无法确保完成我们想做的清理工作。
解决方法：
如果异常不可避免，则应在析构函数内捕获，而不应当抛出。
在析构函数中使用 <code>try-catch</code> 块屏蔽所有异常。
附加说明:
<strong>(后果1):</strong> 如果某一个异常发生,某对象的析构函数被调用,而此时析构发生了异常并流出了函数之外,则函数会被立即terminate掉(函数外有catch也不能拯救)</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="类如何实现--只能静态分配--和--只能动态分配">类如何实现  <code>只能静态分配</code>  和  <code>只能动态分配</code><a href="#类如何实现--只能静态分配--和--只能动态分配" class="hash-link" aria-label="Direct link to 类如何实现--只能静态分配--和--只能动态分配" title="Direct link to 类如何实现--只能静态分配--和--只能动态分配">​</a></h2>
<p>只能在堆上建立
分析: 类对象只能建立在堆上，就是不能<strong>静态建立类对象</strong>，即不能<strong>直接调用类的构造函数</strong>。
实现方式: 将<strong>析构函数设为私有或则受保护</strong>
方法分析:
静态建立:
当对象 <code>建立</code> 在栈上面时，是由编译器分配内存空间的，调用 <code>构造函数</code> 来 <code>构造</code> 栈对象。
当对象使用 <code>完</code> 后，编译器会调用 <code>析构函数</code> 来 <code>释放</code> 栈对象所占的空间。
编译器管理了对象的整个生命周期。
编译器在为类对象<strong>分配栈空间</strong>时，会<strong>先检查类的析构函数的访问性</strong>，
其实不光是析构函数，只要是非静态的函数，编译器都会进行检查。
如果类的析构函数是私有的，则编译器不会在栈空间上为类对象分配内存。
因此，将析构函数设为私有，类对象就无法建立在栈上了。
由此引发的问题:
因为析构函数设置为了私有
需要设置一个 <code>public函数</code> 来调用析构函数</p>
<div class="language-cpp codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-cpp codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">				  </span><span class="token keyword" style="color:#00009f">class</span><span class="token plain">  </span><span class="token class-name">A</span><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">				  </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">				  </span><span class="token keyword" style="color:#00009f">protected</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">:</span><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">				      </span><span class="token function" style="color:#d73a49">A</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">{</span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">				      </span><span class="token operator" style="color:#393A34">~</span><span class="token function" style="color:#d73a49">A</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">{</span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">				  </span><span class="token keyword" style="color:#00009f">public</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">:</span><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">				      </span><span class="token keyword" style="color:#00009f">static</span><span class="token plain">  A</span><span class="token operator" style="color:#393A34">*</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">create</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">				      </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">				          </span><span class="token keyword" style="color:#00009f">return</span><span class="token plain">   </span><span class="token keyword" style="color:#00009f">new</span><span class="token plain">  </span><span class="token function" style="color:#d73a49">A</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">				      </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">				      </span><span class="token keyword" style="color:#00009f">void</span><span class="token plain">  </span><span class="token function" style="color:#d73a49">destory</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">				      </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">				          </span><span class="token keyword" style="color:#00009f">delete</span><span class="token plain">   </span><span class="token keyword" style="color:#00009f">this</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">				      </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">				  </span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain">  </span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>只能在栈上建立
只有使用new运算符，对象才会建立在堆上，因此，只要禁用new运算符就可以实现类对象只能建立在栈上。<strong>将operator new()设为私有即可</strong>。
**注意: 重载了 <code>new</code> 就需要重载 <code>delete</code> **</p>
<div class="language-cpp codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-cpp codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">					  </span><span class="token keyword" style="color:#00009f">class</span><span class="token plain">  </span><span class="token class-name">A</span><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">					  </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">					  </span><span class="token keyword" style="color:#00009f">private</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">:</span><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">					      </span><span class="token keyword" style="color:#00009f">void</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">*</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">operator</span><span class="token plain">  </span><span class="token keyword" style="color:#00009f">new</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain"> size_t  t</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">{</span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain">      </span><span class="token comment" style="color:#999988;font-style:italic">// 注意函数的第一个参数和返回值都是固定的   </span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">					      </span><span class="token keyword" style="color:#00009f">void</span><span class="token plain">  </span><span class="token keyword" style="color:#00009f">operator</span><span class="token plain">  </span><span class="token keyword" style="color:#00009f">delete</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">void</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">*</span><span class="token plain"> ptr</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">{</span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain">  </span><span class="token comment" style="color:#999988;font-style:italic">// 重载了new就需要重载delete   </span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">					  </span><span class="token keyword" style="color:#00009f">public</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">:</span><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">					      </span><span class="token function" style="color:#d73a49">A</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">{</span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">					      </span><span class="token operator" style="color:#393A34">~</span><span class="token function" style="color:#d73a49">A</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">{</span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">					  </span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> </span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="什么情况会自动生成默认构造函数">什么情况会自动生成默认构造函数？<a href="#什么情况会自动生成默认构造函数" class="hash-link" aria-label="Direct link to 什么情况会自动生成默认构造函数？" title="Direct link to 什么情况会自动生成默认构造函数？">​</a></h2>
<p>四种情况:
类成员对象带有默认构造函数.
基类带有默认构造函数
类中存在虚函数
继承体系中存在虚继承
<strong>在合成的默认构造函数中，只有基类子对象和类类型对象会被初始化</strong>，而其他所有的非静态成员(如整数，指针，数组等)，都不会初始化，对他们进行初始化的应该是程序员，而非编译器。
注意：值类型的默认值并不是默认构造的初始化。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="什么是类的继承">什么是类的继承？<a href="#什么是类的继承" class="hash-link" aria-label="Direct link to 什么是类的继承？" title="Direct link to 什么是类的继承？">​</a></h2>
<p>类与类之间的关系
<code>(has-A)</code> 包含关系，即一个类的成员属性是另一个已经定义好的类
<code>(use-A)</code> 使用关系, 一个类使用另一个类，通过类之间的成员函数相互联系，定义友元或者通过传递参数的方式实现；
<code>(is-A)</code> 继承关系, 继承关系，关系具有传递性；
继承的相关概念
所谓的继承就是一个类继承了另一个类的属性和方法，这个新的类包含了上一个类的属性和方法，
被称为子类或者派生类，被继承的类称为父类或者基类；
继承的特点
子类拥有父类的所有属性和方法，子类对象可以当做父类对象使用；
子类可以拥有父类没有的属性和方法；
继承中的访问控制
<code>public</code> 、 <code>protected</code> 、 <code>private</code>
继承中的构造和析构函数
子类中构造函数的 调用顺序为: 基类构造函数, 成员对象构造函数, 派生类构造函数
子类中析构函数的调用顺序为: 派生类析构函数, 成员对象析构函数, 基类析构函数
继承中的兼容性原则
类型兼容规则是指在需要基类对象的任何地方，都可以使用公有派生类的对象来替代。
参考: <a href="https://www.cnblogs.com/zhangyaoqi/p/4591571.html" target="_blank" rel="noopener noreferrer">继承中的类型兼容性原则 - Say舞步 - 博客园</a></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="抽象基类为什么不能创建对象">抽象基类为什么不能创建对象<a href="#抽象基类为什么不能创建对象" class="hash-link" aria-label="Direct link to 抽象基类为什么不能创建对象" title="Direct link to 抽象基类为什么不能创建对象">​</a></h2>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="抽象类的定义带有纯虚函数的类为抽象类抽象类的作用抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中由它来为派生类提供一个公共的根派生类将具体实现在其基类中作为接口的操作所以抽象类实际上刻画了一组子类的操作接口的通用语义这些语义也传给子类子类可以具体实现这些语义也可以再将这些语义传给自己的子类使用抽象类时注意抽象类只能作为基类来使用其纯虚函数的实现由派生类给出如果派生类中没有给出所有纯虚函数的实现而只是继承基类的纯虚函数则这个派生类仍然是一个抽象类如果派生类中给出了所有纯虚函数的实现则该派生类就不再是抽象类了它是一个可以建立对象的具体的类抽象类是不能定义对象的">抽象类的定义：<strong>带有纯虚函数的类</strong>为抽象类。
抽象类的作用：
抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根，派生类将具  体实现在其基类中作为接口的操作。
所以抽象类实际上刻画了一组子类的<strong>操作接口</strong>的通用语义，这些语义也传给子类，子类可以具体实现这些语义，也可以再将这些语义传给自己的子类。
使用抽象类时注意：
抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。
如果<strong>派生类中没有给出所有纯虚函数的实现</strong>，而只是继承基类的纯虚函数，则这个<strong>派生类仍然是一个抽象类</strong>。
如果<strong>派生类中给出了所有纯虚函数的实现</strong>，则该<strong>派生类就不再是抽象类</strong>了，它是一个可以建立对象的具体的类。
<strong>抽象类是不能定义对象的</strong>。<a href="#抽象类的定义带有纯虚函数的类为抽象类抽象类的作用抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中由它来为派生类提供一个公共的根派生类将具体实现在其基类中作为接口的操作所以抽象类实际上刻画了一组子类的操作接口的通用语义这些语义也传给子类子类可以具体实现这些语义也可以再将这些语义传给自己的子类使用抽象类时注意抽象类只能作为基类来使用其纯虚函数的实现由派生类给出如果派生类中没有给出所有纯虚函数的实现而只是继承基类的纯虚函数则这个派生类仍然是一个抽象类如果派生类中给出了所有纯虚函数的实现则该派生类就不再是抽象类了它是一个可以建立对象的具体的类抽象类是不能定义对象的" class="hash-link" aria-label="Direct link to 抽象类的定义带有纯虚函数的类为抽象类抽象类的作用抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中由它来为派生类提供一个公共的根派生类将具体实现在其基类中作为接口的操作所以抽象类实际上刻画了一组子类的操  作接口的通用语义这些语义也传给子类子类可以具体实现这些语义也可以再将这些语义传给自己的子类使用抽象类时注意抽象类只能作为基类来使用其纯虚函数的实现由派生类给出如果派生类中没有给出所有纯虚函数的实现而只是继承基类的纯虚函数则这个派生类仍然是一个抽象类如果派生类中给出了所有纯虚函数的实现则该派生类就不再是抽象类了它是一个可以建立对象的具体的类抽象类是不能定义对象的" title="Direct link to 抽象类的定义带有纯虚函数的类为抽象类抽象类的作用抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中由它来为派生类提供一个公共的根派生类将具体实现在其基类中作为接口的操作所以抽象类实际上刻画了一组子类的操作接口的通用语义这些语义也传给子类子类可以具体实现这些语义也可以再将这些语义传给自己的子类使用抽象类时注意抽象类只能作为基类来使用其纯虚函数的实现由派生类给出如果派生类中没有给出所有纯虚函数的实现而只是继承基类的纯虚函数则这个派生类仍然是一个抽象类如果派生类中给出了所有纯虚函数的实现则该派生类就不再是抽象类了它是一个可以建立对象的具体的类抽象类是不能定义对象的">​</a></h2>
<p>纯虚函数定义: 纯虚函数是一种特殊的虚函数，它的一般格式如下：</p>
<div class="language-cpp codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-cpp codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">		  </span><span class="token keyword" style="color:#00009f">class</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">&lt;</span><span class="token plain">类名</span><span class="token operator" style="color:#393A34">&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">		  </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">		  	</span><span class="token keyword" style="color:#00009f">virtual</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">&lt;</span><span class="token plain">类型</span><span class="token operator" style="color:#393A34">&gt;</span><span class="token operator" style="color:#393A34">&lt;</span><span class="token plain">函数名</span><span class="token operator" style="color:#393A34">&gt;</span><span class="token punctuation" style="color:#393A34">(</span><span class="token operator" style="color:#393A34">&lt;</span><span class="token plain">参数表</span><span class="token operator" style="color:#393A34">&gt;</span><span class="token punctuation" style="color:#393A34">)</span><span class="token operator" style="color:#393A34">=</span><span class="token number" style="color:#36acaa">0</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">		  	…</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">		  </span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>纯虚函数引入原因
为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。
在很多情况下，基类本身生成对象是不合情理的。
例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。
为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数(方法:  <code>virtual ReturnType Function()= 0;</code> )。
若要使派生类为非抽象类，则编译器要求在派生类中，必须对纯虚函数予以重载以实现多态性。
<strong>同时含有纯虚函数的类称为抽象类</strong>，它不能生成对象。
相似概念
多态性
指相同对象收到不同消息或不同对象收到相同消息时产生不同的实现动作。
C++支持两种多态性：编译时多态性，运行时多态性。
编译时多态性(静态多态)：通过重载函数实现。
运行时多态性(动态多态)：通过虚函数实现。
虚函数
虚函数是在基类中被声明为 <code>virtual</code> ，并在派生类中重新定义的成员函数，可实现成员函数的动态重载。
抽象类
包含纯虚函数的类称为抽象类。由于抽象类包含了没有定义的纯虚函数，所以不能定义抽象类的对象。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="类什么时候会析构">类什么时候会析构？<a href="#类什么时候会析构" class="hash-link" aria-label="Direct link to 类什么时候会析构？" title="Direct link to 类什么时候会析构？">​</a></h2>
<p>对于静态对象: 当离开作用区域之后, 对象生命周期结束, 编译器会自动调用析构函数
对于动态对象: 当对对象指针调用delete时, 会调用析构函数终止对象生命周期并释放内存. 其中对象指针指针可以对象类型的指针, 也可以时基类指针(注意基类析构函数位虚函数)
第三种情况: 当对象中存在嵌入对象时, 该对象析构时, 嵌入对象也会被析构</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="介绍一下c里面的多态">介绍一下C++里面的多态？<a href="#介绍一下c里面的多态" class="hash-link" aria-label="Direct link to 介绍一下C++里面的多态？" title="Direct link to 介绍一下C++里面的多态？">​</a></h2>
<p>静态多态(重载, 模板): 是在编译的时候，就确定调用函数的类型。
动态多态(覆盖, 虚函数实现): 在运行的时候，才确定调用的是哪个函数，动态绑定。运行基类指针指向派生类的对象，并调用派生类的函数。
参考: <a href="https://zhaostu4.github.io/2019/11/28/%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB-C++%E5%9F%BA%E7%A1%80/#%E7%90%86%E8%A7%A3%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E5%A4%9A%E6%80%81" target="_blank" rel="noopener noreferrer">理解的虚函数和多态</a>
函数重载:
同一可访问区域内, 存在多个不同参数列表的同名函数, 由编译器根据调用参数决定那个函数应该被调用
函数重载不关心返回值类型, 但是对于函数类型时关心的, 例如类中的两个函数拥有相同参数列表的同名函数, 一个为const类型, 一个为非const类型, 依旧时属于函数重载.
函数模板:
模板函数会经历两遍编译:
(模板编译)在定义模板函数时对模板本身进行编译
(模板实例化)在调用时对参数进行替换, 对替换参数后的代码进行编译
虽然它和函数重载类似都可以根据参数确定将要调用的函数版本, 但是函数模板只会生成将要用到的函数版本, 而函数模板无论是否调用其代码都会生成.
覆盖: 是指派生类中重新定义了基类中的 <code>virtual</code> 函数
<strong>隐藏</strong>：是指派生类的函  数屏蔽了与其同名的基类函数，只要函数名相同，基类函数都会被隐藏. 不管参数列表是否相同。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="用c-语言实现c的继承">用C 语言实现C++的继承<a href="#用c-语言实现c的继承" class="hash-link" aria-label="Direct link to 用C 语言实现C++的继承" title="Direct link to 用C 语言实现C++的继承">​</a></h2>
<p>关键点:
使用函数指针保存函数
将基类放在结构题的头部, 这样强转的就不会出错了</p>
<div class="language-cpp codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-cpp codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">			  </span><span class="token macro property directive-hash" style="color:#36acaa">#</span><span class="token macro property directive keyword" style="color:#00009f">include</span><span class="token macro property" style="color:#36acaa"> </span><span class="token macro property string" style="color:#e3116c">&lt;iostream&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">			  </span><span class="token keyword" style="color:#00009f">using</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">namespace</span><span class="token plain"> std</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">			  </span><span class="token comment" style="color:#999988;font-style:italic">//C++中的继承与多态</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">			  </span><span class="token keyword" style="color:#00009f">struct</span><span class="token plain"> </span><span class="token class-name">A</span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">			  	</span><span class="token keyword" style="color:#00009f">virtual</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">void</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">fun</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> 	</span><span class="token punctuation" style="color:#393A34">{</span><span class="token comment" style="color:#999988;font-style:italic">//C++中的多态:通过虚函数实现</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">			  		cout</span><span class="token operator" style="color:#393A34">&lt;&lt;</span><span class="token string" style="color:#e3116c">&quot;A:fun()&quot;</span><span class="token operator" style="color:#393A34">&lt;&lt;</span><span class="token plain">endl</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">			  	</span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">			  	</span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> a</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">			  </span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">			  </span><span class="token keyword" style="color:#00009f">struct</span><span class="token plain"> </span><span class="token class-name">B</span><span class="token operator" style="color:#393A34">:</span><span class="token base-clause keyword" style="color:#00009f">public</span><span class="token base-clause"> </span><span class="token base-clause class-name">A</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token comment" style="color:#999988;font-style:italic">//C++中的继承:B 类公有继承A 类</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">			  	</span><span class="token keyword" style="color:#00009f">virtual</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">void</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">fun</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">//C++中的多态:通过虚函数实现（子类的关键字virtual 可加可不加）</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">			  		cout</span><span class="token operator" style="color:#393A34">&lt;&lt;</span><span class="token string" style="color:#e3116c">&quot;B:fun()&quot;</span><span class="token operator" style="color:#393A34">&lt;&lt;</span><span class="token plain">endl</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">			  	</span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">			  	</span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> b</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">			  </span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">			  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">			  </span><span class="token comment" style="color:#999988;font-style:italic">//C 语言模拟C++的继承与多态</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">			  </span><span class="token keyword" style="color:#00009f">typedef</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">void</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token operator" style="color:#393A34">*</span><span class="token plain">FUN</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">//定义一个函数指针来实现对成员函数的继承</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">			  </span><span class="token keyword" style="color:#00009f">struct</span><span class="token plain"> </span><span class="token class-name">_A</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">//父类</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">			  	FUN _fun</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">//由于C 语言中结构体不能包含函数，故只能用函数指针在外面实现</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">			  	</span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> _a</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">			  </span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">			  </span><span class="token keyword" style="color:#00009f">struct</span><span class="token plain"> </span><span class="token class-name">_B</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">//子类</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">			  	_A _a_</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">//  在子类中定义一个基类的对象即可实现对父类的继承</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">			  	</span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> _b</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">			  </span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">			  </span><span class="token keyword" style="color:#00009f">void</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">_fA</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">//父类的同名函数</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">			  	</span><span class="token function" style="color:#d73a49">printf</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">&quot;_A:_fun()\n&quot;</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">			  </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">			  </span><span class="token keyword" style="color:#00009f">void</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">_fB</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">//子类的同名函数</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">			  	</span><span class="token function" style="color:#d73a49">printf</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">&quot;_B:_fun()\n&quot;</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">			  </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">			  </span><span class="token keyword" style="color:#00009f">void</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">Test</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">			  </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">			  	</span><span class="token comment" style="color:#999988;font-style:italic">//测试C++中的继承与多态</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">			  	A a</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">//定义一个父类对象a</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">			  	B b</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">//定义一个子类对象b</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">			  	A</span><span class="token operator" style="color:#393A34">*</span><span class="token plain"> p1 </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">&amp;</span><span class="token plain">a</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">//定义一个父类指针指向父类的对象</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">			  	p1</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token function" style="color:#d73a49">fun</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">//调用父类的同名函数</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">			  	p1 </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">&amp;</span><span class="token plain">b</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">//让父类指针指向子类的对象</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">			  	p1</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token function" style="color:#d73a49">fun</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">//调用子类的同名函数</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">			  	</span><span class="token comment" style="color:#999988;font-style:italic">//C 语言模拟继承与多态的测试</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">			  	_A _a</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">//定义一个父类对象_a</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">			  	_B _b</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">//定义一个子类对象_b</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">			  	_a</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">_fun </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> _fA</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">//父类的对象调用父类的同名函数</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">			  	_b</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">_a_</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">_fun </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> _fB</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">//子类的对象调用子类的同名函数</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">			  	_A</span><span class="token operator" style="color:#393A34">*</span><span class="token plain"> p2 </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">&amp;</span><span class="token plain">_a</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">//定义一个父类指针指向父类的对象</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">			  	p2</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token function" style="color:#d73a49">_fun</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">//调用父类的同名函数</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">			  	p2 </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">_A</span><span class="token operator" style="color:#393A34">*</span><span class="token punctuation" style="color:#393A34">)</span><span class="token operator" style="color:#393A34">&amp;</span><span class="token plain">_b</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">//让父类指针指向子类的对象,由于类型不匹配所以要进行强转</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">			  	p2</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token function" style="color:#d73a49">_fun</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">//调用子类的同名函数</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">			  </span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="继承机制中对象之间如何转换指针和引用之间如何转换">继承机制中对象之间如何转换？指针和引用之间如何转换？<a href="#继承机制中对象之间如何转换指针和引用之间如何转换" class="hash-link" aria-label="Direct link to 继承机制中对象之间如何转换？指针和引用之间如何转换？" title="Direct link to 继承机制中对象之间如何转换？指针和引用之间如何转换？">​</a></h2>
<p>派生类的对象可以当做基类对象使用， 例如赋值或则初始化等
派生类对象的地址可以赋给指向基类的指针。 在替代之后，派生类对象就可以作为基类的对象使用，但只能使用从基类继承的成员。
向上类型转换(派生类转基类, 总是安全的)
将派生类指针或引用转换为基类的指针或引用被称为向上类型转换，<strong>向上类型转换会自动进行</strong>，而且向上类型转换是安全的。
向下类型转换(基类转派生类, 不安全)
将基类指针或引用转换为派生类指针或引用被称为向下类型转换，向下类型转换不会自动进行，因为一个基类对应几个派生类，所以向下类型转换时不知道对应哪个派生类，所以在向下类型转换时必须加动态类型识别技术。
<code>RTTI</code> 技术，用dynamic_cast进行向下类型转换, 只有存在虚函数的类才能使用 <code>RTTI</code>
<a href="https://blog.csdn.net/qq_22660775/article/details/88715548" target="_blank" rel="noopener noreferrer">浅谈C++类型转换的安全性 - freshman94的博客 - CSDN博客</a>
<a href="https://blog.csdn.net/vjhghjghj/article/details/90677092#%C2%A0%E7%BB%A7%E6%89%BF%E7%9A%84%E8%B5%8B%E5%80%BC%E5%85%BC%E5%AE%B9%E8%A7%84%E5%88%99" target="_blank" rel="noopener noreferrer">继承的赋值兼容规则</a>update</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="组合与继承优缺点">组合与继承优缺点？<a href="#组合与继承优缺点" class="hash-link" aria-label="Direct link to 组合与继承优缺点？" title="Direct link to 组合与继承优缺点？">​</a></h2>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="继承-继承是is-a-的关系比如说student-继承person则说明student-is-a-person继承的优点-是子类可以重写父类的方法来方便地实现对父类的扩展继承的缺点有以下几点父类的内部细节对子类是可见的可以自己调用父类的方法子类从父类继承的方法在编译时就确定下来了所以无法在运行期间改变从父类继承的方法的行为如果对父类的方法做了修改的话比如增加了一个参数则子类的方法必须做出相应的修改所以说子类与父类是一种高耦合违背了面向对象思想">继承: 继承是Is a 的关系，比如说Student 继承Person,则说明Student is a Person。
继承的优点: 是子类可以重写父类的方法来方便地实现对父类的扩展。
继承的缺点有以下几点：
父类的<strong>内部细节</strong>对子类是<strong>可见</strong>的。(可以自己调用父类的方法)
子类从父类继承的方法在编译时就确定下来了，所以无法在运行期间改变从父类继承的方法的行为。
如果对父类的方法做了修改的话（比如增加了一个参数），则子类的方法必须做出相应的修改。所以说子类与父类是一种高耦合，违背了面向对象思想。<a href="#继承-继承是is-a-的关系比如说student-继承person则说明student-is-a-person继承的优点-是子类可以重写父类的方法来方便地实现对父类的扩展继承的缺点有以下几点父类的内部细节对子类是可见的可以自己调用父类的方法子类从父类继承的方法在编译时 就确定下来了所以无法在运行期间改变从父类继承的方法的行为如果对父类的方法做了修改的话比如增加了一个参数则子类的方法必须做出相应的修改所以说子类与父类是一种高耦合违背了面向对象思想" class="hash-link" aria-label="Direct link to 继承-继承是is-a-的关系比如说student-继承person则说明student-is-a-person继承的优点-是子类可以重写父类的方法来方便地实现对父类的扩展继承的缺点有以下几点父类的内部细节对子类是可见的可以自己调用父类的方法子类从父类继承的方法在编译时就确定下来了所以无法在运行期间改变从父类继承的方法的行为如果对父类的方法做了修改的话比如增加了一个参数则子类的方法必须做出相应的修改所以说子类与父类是一种高耦合违背了面向对象思想" title="Direct link to 继承-继承是is-a-的关系比如说student-继承person则说明student-is-a-person继承的优点-是子类可以重写父类的方法来方便地实现对父类的扩展继承的缺点有以下几点父类的内部细节对子类是可见的可以自己调用父类的方法子类从父类继承的方法在编译时就确定下来了所以无法在运行期间改变从父类继承的方法的行为如果对父类的方法做了修改的话比如增加了一个参数则子类的方法必须做出相应的修改所以说子类与父类是一种高耦合违背了面向对象思想">​</a></h2>
<p>组合(嵌入式对象): 组合也就是设计类的时候把要组合的类的对象加入到该类中作为自己的成员变量。
组合的优点：
当前对象只能通过所包含的那个对象去调用其方法，所以所包含的对象的<strong>内部细节</strong>对当前对象时<strong>不可见</strong>的。(必须通过嵌入式对象调用嵌入式对象的方法)
当前对象与包含的对象是一个低耦合关系，如果修改包含对象的类中代码不需要修改当前对象类的代码。
当前对象可以在运行时动态的绑定所包含的对象。可以通过set 方法给所包含对象赋值。
组合的缺点：
容易产生过多的对象。
为了能组合多个对象，必须仔细对接口进行定义
参考: <a href="https://blog.csdn.net/u013675978/article/details/82628710" target="_blank" rel="noopener noreferrer">继承的优点和缺点</a></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="左值右值">左值右值<a href="#左值右值" class="hash-link" aria-label="Direct link to 左值右值" title="Direct link to 左值右值">​</a></h2>
<p>lvalue:具名且不可被移动
xvaue:具名且可被移动
prvalue:不具名且可被移动
glvalue:具名，lvalue和xvalue都属于glvalue
rvalue:可被移动的表达式，prvalue和xvalue都属于rvalue
右值
字面值或者函数返回的非引用都是纯右值。
以下表达式的值都是纯右值：
字面值(字符串字面值除外)，例如1，&#x27;a&#x27;, true等
返回值为非引用的函数调用或操作符重载，例如：str.substr(1, 2), str1 + str2, or it++
后置自增和自减表达式(a++, a--)
算术表达式
逻辑表达式
比较表达式
取地址表达式
lambda表达式</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="c-语言的编译链接过程">C 语言的编译链接过程？<a href="#c-语言的编译链接过程" class="hash-link" aria-label="Direct link to C 语言的编译链接过程？" title="Direct link to C 语言的编译链接过程？">​</a></h2>
<p>源代码－－&gt;预处理－－&gt;编译－－&gt;优化－－&gt;汇编－－&gt;链接--&gt;可执行文件</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="虚函数">虚函数<a href="#虚函数" class="hash-link" aria-label="Direct link to 虚函数" title="Direct link to 虚函数">​</a></h2>
<p>多态的实现主要分为静态多态和动态多态，静态多态主要是重载，在编译的时候就已经确定；动态多态是用虚函数机制实现的，在运行期间动态绑定
在父 类中声明为加了virtual关键字的函数，在子类中重写时候不需要加virtual也是虚函数
简述C++虚函数作用及底层实现原理
C++中虚函数使用虚函数表和 虚函数表指针实现，虚函数表是一个类的虚函数的地址表，用于索引类本身以及父类的虚函数的地 址，假如子类的虚函数重写了父类的虚函数，则对应在虚函数表中会把对应的虚函数替换为子类的 虚函数的地址；虚函数表指针存在于每个对象中（通常出于效率考虑，会放在对象的开始地址处）， 它指向对象所在类的虚函数表的地址；在多继承环境下，会存在多个虚函数表指针，分别指向对应 不同基类的虚函数表。
<strong>如果要生成子类虚表,就要经过三个步骤:</strong>
第一步,将父类虚表内容<strong>拷贝</strong>到子类虚表上;
第二步,将子类重<strong>写的虚函数覆盖掉表</strong>中父类的虚函数;
第三步,如果子类有<strong>新增加</strong>的虚函数,按声明次序加到最后
一个对象访问普通成员函数和虚函数哪个更快
访问普通成员函数更快，因为普通成员函数的地址在编译阶段就已确定，因此在访问时直接调 用对应地址的函数，而虚函数在调用时，需要首先在虚函数表中寻找虚函数所在地址，因此相比普 通成员函数速度要慢一些
在什么情况下，析构函数需要是虚函数
若存在类继承关系并且析构函数中需要析构某些资源时，析构函数需要是虚函数，否则当使用父类指针指向子类对象，在delete时只会调用父类的析构函数，而不能调用子类的析构函数，造成内存泄露等问题
内联函数、构造函数、静态成员函数可以是虚函数吗
都不可以。内联函数需要在编译阶段展开，而虚函数是运行时动态绑定的，编译时无法展开； 构造函数在进行调用时还不存在父类和子类的概念，父类只会调用父类的构造函数，子类调用子类 的，因此不存在动态绑定的概念；静态成员函数是以类为单位的函数，与具体对象无关，虚函数是 与对象动态绑定的，因此是两个不冲突的概念；
请你回答一下为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数
将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。
C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。
在有继承关系的父子类中，构建和析构一个子类对象时，父子构造函数和析构函数的执行顺序分别是怎样的
先去调用(call)派生类中的构造函数， 在进入函数体之前 ，先去调用(call)基类的构造函数，基类构造函数执行完毕后，再继续执行派生类中的构造函数，执行完毕对象创建成功。
基类构造函数的调用是在派生类构造函数初始化列表之前还是之后呢?
虽然在汇编代码中，是先调用的派生类的构造函数，但是总的来说，基类的构造函数还是先于派生类的构造函数里的语句先执行，也就是说，基类对象先于派生类对象被创建。
派生类对象中基类析构函数和派生类析构函数调用顺序
先执行派生类的析构函数，然后再去执行基类的析构函数</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-tags-row"><div class="col"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/docs/tags/work">work</a></li></ul></div></div><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col"><a href="https://github.com/facebook/docusaurus/edit/main/website/docs/cpp/interview.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_JAkA"><span class="theme-last-updated">Last updated<!-- --> on <b><time datetime="2025-02-24T13:09:37.000Z" itemprop="dateModified">Feb 24, 2025</time></b></span></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/cpp/inline"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">inline 总结</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/cpp/lambda"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">C++ 的 lambda 表达式</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#引用和指针的区别" class="table-of-contents__link toc-highlight">引用和指针的区别</a></li><li><a href="#c中的指针参数传递和引用参数传递" class="table-of-contents__link toc-highlight">C++中的指针参数传递和引用参数传递</a></li><li><a href="#形参与实参的区别" class="table-of-contents__link toc-highlight">形参与实参的区别</a></li><li><a href="#static的用法" class="table-of-contents__link toc-highlight"><code>static</code>的用法</a><ul><li><a href="#静态函数" class="table-of-contents__link toc-highlight">静态函数</a></li><li><a href="#类的静态成员" class="table-of-contents__link toc-highlight">类的静态成员</a></li><li><a href="#类的静态函数" class="table-of-contents__link toc-highlight">类的静态函数</a></li></ul></li><li><a href="#静态变量什么时候初始化" class="table-of-contents__link toc-highlight">静态变量什么时候初始化</a></li><li><a href="#mutable" class="table-of-contents__link toc-highlight"><code>mutable</code></a></li><li><a href="#extern-用法" class="table-of-contents__link toc-highlight"><code>extern</code> 用法？</a></li><li><a href="#虚函数可以声明为inline吗" class="table-of-contents__link toc-highlight">虚函数可以声明为<code>inline</code>吗?</a></li><li><a href="#类成员初始化方式构造函数的执行顺序为什么用成员初始化列表会快一些" class="table-of-contents__link toc-highlight">类成员初始化方式？构造函数的执行顺序？为什么用成员初始化列表会快一些？</a></li><li><a href="#构造函数为什么不能为虚函数析构函数为什么要虚函数" class="table-of-contents__link toc-highlight">构造函数为什么不能为虚函数？析构函数为什么要虚函数？</a><ul><li><a href="#构造函数为什么不能为虚函数" class="table-of-contents__link toc-highlight">构造函数为什么不能为虚函数?</a></li><li><a href="#析构函数为什么要虚函数" class="table-of-contents__link toc-highlight">析构函数为什么要虚函数？</a></li></ul></li><li><a href="#析构函数的作用如何起作用" class="table-of-contents__link toc-highlight">析构函数的作用，如何起作用？</a></li><li><a href="#构造函数和析构函数可以调用虚函数吗" class="table-of-contents__link toc-highlight">构造函数和析构函数可以调用虚函数吗</a></li><li><a href="#虚析构函数的作用父类的析构函数是否要设置为虚函数" class="table-of-contents__link toc-highlight">虚析构函数的作用，父类的析构函数是否要设置为虚函数？</a></li><li><a href="#构造函数---析构函数--可以调用虚函数吗" class="table-of-contents__link toc-highlight"><code>构造函数</code>   <code>析构函数</code>  可以调用虚函数吗？</a></li><li><a href="#构造函数-----析构函数--可否抛出异常" class="table-of-contents__link toc-highlight"><code>构造函数</code>  ,    <code>析构函数</code>  可否抛出异常</a></li><li><a href="#类如何实现--只能静态分配--和--只能动态分配" class="table-of-contents__link toc-highlight">类如何实现  <code>只能静态分配</code>  和  <code>只能动态分配</code></a></li><li><a href="#什么情况会自动生成默认构造函数" class="table-of-contents__link toc-highlight">什么情况会自动生成默认构造函数？</a></li><li><a href="#什么是类的继承" class="table-of-contents__link toc-highlight">什么是类的继承？</a></li><li><a href="#抽象基类为什么不能创建对象" class="table-of-contents__link toc-highlight">抽象基类为什么不能创建对象</a></li><li><a href="#抽象类的定义带有纯虚函数的类为抽象类抽象类的作用抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中由它来为派生类提供一个公共的根派生类将具体实现在其基类中作为接口的操作所以抽象类实际上刻画了一组子类的操作接口的通用语义这些语义也传给子类子类可以具体实现这些语义也可以再将这些语义传给自己的子类使用抽象类时注意抽象类只能作为基类来使用其纯虚函数的实现由派生类给出如果派生类中没有给出所有纯虚函数的实现而只是继承基类的纯虚函数则这个派生类仍然是一个抽象类  如果派生类中给出了所有纯虚函数的实现则该派生类就不再是抽象类了它是一个可以建立对象的具体的类抽象类是不能定义对象的" class="table-of-contents__link toc-highlight">抽象类的定义：<strong>带有纯虚函数的类</strong>为抽象类。
抽象类的作用：
抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根，派生类将具体实现在其基类中作为接口的操作。
所以抽象类实际上刻画了一组子类的<strong>操作接口</strong>的通用语义，这些语义也传给子类，子类可以具体实现这些语义，也可以再将这些语义传给自己的子类。
使用抽象类时注意：
抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。
如果<strong>派生类中没有给出所有纯虚函数的实现</strong>，而只是继承基类的纯虚函数，则这个<strong>派生类仍然是一个抽象类</strong>。
如果<strong>派生类中给出了所有纯虚函数的实现</strong>，则该<strong>派生类就不再是抽象类</strong>了，它是一个可以建立对象的具体的类。
<strong>抽象类是不能定义对象的</strong>。</a></li><li><a href="#类什么时候会析构" class="table-of-contents__link toc-highlight">类什么时候会析构？</a></li><li><a href="#介绍一下c里面的多态" class="table-of-contents__link toc-highlight">介绍一下C++里面的多态？</a></li><li><a href="#用c-语言实现c的继承" class="table-of-contents__link toc-highlight">用C 语言实现C++的继承</a></li><li><a href="#继承机制中对象之间如何转换指针和引用之间如何转换" class="table-of-contents__link toc-highlight">继承机制中对象之间如何转换？指针和引用之间如何转换？</a></li><li><a href="#组合与继承优缺点" class="table-of-contents__link toc-highlight">组合与继承优缺点？</a></li><li><a href="#继承-继承是is-a-的 关系比如说student-继承person则说明student-is-a-person继承的优点-是子类可以重写父类的方法来方便地实现对父类的扩展继承的缺点有以下几点父类的内部细节对子类是可见的可以自己调用父类的方法子类从父类继承的方法在编译时就确定下来了所以无法在运行期间改变从父类继承的方法的行为如果对父类的方法做了修改的话比如增加了一个参数则子类的方法必须做出相应的修改所以说子类与父类是一种高耦合违背了面向对象思想" class="table-of-contents__link toc-highlight">继承: 继承是Is a 的关系，比如说Student 继承Person,则说明Student is a Person。
继承的优点: 是子类可以重写父类的方法来方便地实现对父类的扩展。
继承的缺点有以下几点：
父类的<strong>内部细节</strong>对子类是<strong>可见</strong>的。(可以自己调用父类的方法)
子类从父类继承的方法在编译时就确定下来了，所以无法在运行期间改变从父类继承的方法的行为。
如果对父类的方法做了修改的话（比如增加了一个参数），则子类的方法必须做出相应的修改。所以说子类与父类是一种高耦合，违背了面向对象思想。</a></li><li><a href="#左值右值" class="table-of-contents__link toc-highlight">左值右值</a></li><li><a href="#c-语言的编译链接过程" class="table-of-contents__link toc-highlight">C 语言的编译链接过程？</a></li><li><a href="#虚函数" class="table-of-contents__link toc-highlight">虚函数</a></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2025 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>